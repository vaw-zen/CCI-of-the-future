#!/usr/bin/env node

/**
 * SEO Opportunity Analyzer
 * Calculates opportunity scores and prioritizes keywords for optimization
 * Formula: Opportunity Score = (Impressions √ó CTR √ó (1 / Current Position+1)) √ó Search Volume
 */

const fs = require('fs');
const csv = require('csv-parser');
const createCsvWriter = require('csv-writer').createObjectCsvWriter;

class OpportunityAnalyzer {
  constructor() {
    // Environment-aware paths
    const isGitHubActions = process.env.GITHUB_ACTIONS === 'true';
    this.csvPath = isGitHubActions ? 'scripts/data/seo-keywords.csv' : '../../data/seo-keywords.csv';
    this.reportPath = isGitHubActions ? 'scripts/reports/' : '../../reports/';
    
    this.keywords = [];
    this.opportunities = [];
  }

  /**
   * Load keywords from CSV
   */
  async loadKeywords() {
    console.log('üìä Loading SEO keywords data...');
    
    return new Promise((resolve, reject) => {
      this.keywords = [];
      
      fs.createReadStream(this.csvPath)
        .pipe(csv())
        .on('data', (row) => {
          this.keywords.push(row);
        })
        .on('end', () => {
          console.log(`‚úÖ Loaded ${this.keywords.length} keywords`);
          resolve();
        })
        .on('error', reject);
    });
  }

  /**
   * Calculate opportunity score for each keyword
   */
  calculateOpportunityScores() {
    console.log('üîç Calculating opportunity scores...');
    
    this.opportunities = this.keywords.map(keyword => {
      const impressions = parseInt(keyword.Impressions) || 0;
      const ctr = parseFloat(keyword.CTR) || 0;
      const position = parseInt(keyword['Current Position']) || 999;
      const searchVolume = parseInt(keyword['Search Volume']) || 0;
      const clicks = parseInt(keyword.Clicks) || 0;
      
      // Opportunity Score = (Impressions √ó CTR √ó (1 / Current Position+1)) √ó Search Volume
      const positionMultiplier = 1 / (position + 1);
      const opportunityScore = (impressions * (ctr/100) * positionMultiplier * searchVolume);
      
      // Additional scoring factors
      const lowHangingFruit = position >= 5 && position <= 20 && impressions > 100;
      const highCTROpportunity = ctr > 5 && position > 10;
      const notRankingButHasVolume = position === 0 && searchVolume > 200;
      
      return {
        ...keyword,
        OpportunityScore: Math.round(opportunityScore),
        PositionMultiplier: positionMultiplier.toFixed(4),
        LowHangingFruit: lowHangingFruit,
        HighCTROpportunity: highCTROpportunity,
        NotRankingButHasVolume: notRankingButHasVolume,
        PriorityFlag: this.getPriorityFlag(keyword, opportunityScore, position, ctr, searchVolume)
      };
    });
    
    // Sort by opportunity score (highest first)
    this.opportunities.sort((a, b) => b.OpportunityScore - a.OpportunityScore);
    
    console.log(`‚úÖ Calculated opportunity scores for ${this.opportunities.length} keywords`);
  }

  /**
   * Get priority flag for keyword
   */
  getPriorityFlag(keyword, opportunityScore, position, ctr, searchVolume) {
    if (opportunityScore > 10000) return 'üöÄ URGENT';
    if (position >= 5 && position <= 15 && searchVolume > 300) return 'üéØ LOW-HANGING';
    if (ctr > 10 && position > 10) return 'üìà HIGH-CTR';
    if (position === 0 && searchVolume > 200) return 'üîç NOT-RANKING';
    if (keyword['Optimization Status'] === 'Needs Optimization') return 'üîß NEEDS-WORK';
    if (keyword.Trend === 'Declining') return '‚ö†Ô∏è DECLINING';
    if (keyword.Trend === 'Improving') return '‚úÖ MOMENTUM';
    return 'üìã MONITOR';
  }

  /**
   * Generate prioritized keywords report
   */
  async generatePrioritizedReport() {
    const report = `# üéØ SEO Opportunity Prioritization Report

Generated: ${new Date().toLocaleString()}
Total Keywords: ${this.opportunities.length}

## üìä Opportunity Score Distribution

${this.getOpportunityDistribution()}

## üöÄ TOP 20 HIGHEST OPPORTUNITY KEYWORDS

${this.getTop20Opportunities()}

## üéØ LOW-HANGING FRUIT (Positions 5-20 with High Volume)

${this.getLowHangingFruit()}

## üîç NOT RANKING but High Volume (Fix First!)

${this.getNotRankingHighVolume()}

## üìà HIGH CTR OPPORTUNITIES (Good content, bad position)

${this.getHighCTROpportunities()}

## ‚ö†Ô∏è DECLINING KEYWORDS (Urgent attention needed)

${this.getDecliningKeywords()}

## üîß NEEDS OPTIMIZATION (Technical fixes required)

${this.getNeedsOptimizationKeywords()}

---
*Generated by SEO Opportunity Analyzer*
`;

    const reportFile = `${this.reportPath}opportunity-prioritization-report.md`;
    fs.writeFileSync(reportFile, report);
    console.log('üìã Prioritization report saved: opportunity-prioritization-report.md');
  }

  /**
   * Get opportunity score distribution
   */
  getOpportunityDistribution() {
    const distribution = {
      urgent: this.opportunities.filter(k => k.OpportunityScore > 10000).length,
      high: this.opportunities.filter(k => k.OpportunityScore >= 1000 && k.OpportunityScore <= 10000).length,
      medium: this.opportunities.filter(k => k.OpportunityScore >= 100 && k.OpportunityScore < 1000).length,
      low: this.opportunities.filter(k => k.OpportunityScore < 100).length
    };

    return `- **üöÄ Urgent (>10,000):** ${distribution.urgent} keywords
- **üéØ High (1,000-10,000):** ${distribution.high} keywords  
- **üìà Medium (100-1,000):** ${distribution.medium} keywords
- **üìã Low (<100):** ${distribution.low} keywords`;
  }

  /**
   * Get top 20 opportunities
   */
  getTop20Opportunities() {
    return this.opportunities.slice(0, 20).map((k, i) => 
      `${i+1}. **${k.Keyword}** ${k.PriorityFlag}
   - Opportunity Score: **${k.OpportunityScore.toLocaleString()}**
   - Position: ${k['Current Position'] || 'Not Ranking'} | Volume: ${k['Search Volume']} | CTR: ${k.CTR}%
   - Status: ${k['Optimization Status']} | Trend: ${k.Trend}
   - URL: ${k['Target URL']}`
    ).join('\n\n');
  }

  /**
   * Get low-hanging fruit keywords
   */
  getLowHangingFruit() {
    const lowHanging = this.opportunities.filter(k => k.LowHangingFruit);
    
    if (lowHanging.length === 0) return "*No low-hanging fruit identified*";
    
    return lowHanging.slice(0, 15).map(k => 
      `- **${k.Keyword}** (Position ${k['Current Position']})
  - Volume: ${k['Search Volume']} | Impressions: ${k.Impressions} | CTR: ${k.CTR}%
  - üéØ **Action:** Optimize content + build 3-5 quality backlinks to reach top 3`
    ).join('\n\n');
  }

  /**
   * Get not ranking but high volume keywords
   */
  getNotRankingHighVolume() {
    const notRanking = this.opportunities.filter(k => k.NotRankingButHasVolume);
    
    if (notRanking.length === 0) return "*All high-volume keywords are ranking*";
    
    return notRanking.slice(0, 10).map(k => 
      `- **${k.Keyword}** 
  - Volume: ${k['Search Volume']} | Status: ${k['Optimization Status']}
  - üîç **Action:** Create dedicated content + internal links + local backlinks`
    ).join('\n\n');
  }

  /**
   * Get high CTR opportunities
   */
  getHighCTROpportunities() {
    const highCTR = this.opportunities.filter(k => k.HighCTROpportunity);
    
    if (highCTR.length === 0) return "*No high CTR opportunities found*";
    
    return highCTR.slice(0, 10).map(k => 
      `- **${k.Keyword}** (Position ${k['Current Position']}, CTR ${k.CTR}%)
  - Volume: ${k['Search Volume']} | Clicks: ${k.Clicks}
  - üìà **Action:** Content has good CTR - needs better technical SEO + backlinks`
    ).join('\n\n');
  }

  /**
   * Get declining keywords
   */
  getDecliningKeywords() {
    const declining = this.opportunities.filter(k => k.Trend === 'Declining');
    
    if (declining.length === 0) return "*No declining keywords detected*";
    
    return declining.slice(0, 15).map(k => 
      `- **${k.Keyword}** (Position ${k['Current Position']})
  - Volume: ${k['Search Volume']} | CTR: ${k.CTR}% | Status: ${k['Optimization Status']}
  - ‚ö†Ô∏è **Action:** Review content freshness + check for technical issues + competitor analysis`
    ).join('\n\n');
  }

  /**
   * Get keywords needing optimization
   */
  getNeedsOptimizationKeywords() {
    const needsWork = this.opportunities.filter(k => 
      k['Optimization Status'].includes('Needs Optimization') || 
      k['Optimization Status'].includes('Requires Work') ||
      k['Optimization Status'].includes('Not Optimized')
    );
    
    if (needsWork.length === 0) return "*All keywords are properly optimized*";
    
    return needsWork.slice(0, 20).map(k => 
      `- **${k.Keyword}** 
  - Position: ${k['Current Position'] || 'Not Ranking'} | Volume: ${k['Search Volume']}
  - Status: ${k['Optimization Status']} | URL: ${k['Target URL']}
  - üîß **Action:** Title tag + meta description + H1/H2 + schema markup`
    ).join('\n\n');
  }

  /**
   * Export prioritized CSV
   */
  async exportPrioritizedCSV() {
    const csvWriter = createCsvWriter({
      path: `${this.reportPath}prioritized-keywords.csv`,
      header: [
        {id: 'OpportunityScore', title: 'Opportunity Score'},
        {id: 'PriorityFlag', title: 'Priority Flag'},
        {id: 'Keyword', title: 'Keyword'},
        {id: 'Current Position', title: 'Current Position'},
        {id: 'Search Volume', title: 'Search Volume'},
        {id: 'CTR', title: 'CTR'},
        {id: 'Clicks', title: 'Clicks'},
        {id: 'Impressions', title: 'Impressions'},
        {id: 'Trend', title: 'Trend'},
        {id: 'Optimization Status', title: 'Optimization Status'},
        {id: 'Target URL', title: 'Target URL'},
        {id: 'Category', title: 'Category'},
        {id: 'LowHangingFruit', title: 'Low Hanging Fruit'},
        {id: 'HighCTROpportunity', title: 'High CTR Opportunity'},
        {id: 'NotRankingButHasVolume', title: 'Not Ranking But Has Volume'}
      ]
    });

    await csvWriter.writeRecords(this.opportunities);
    console.log('üìä Prioritized CSV exported: prioritized-keywords.csv');
  }

  /**
   * Run complete analysis
   */
  async runAnalysis() {
    console.log('üöÄ Starting SEO Opportunity Analysis...\n');

    try {
      await this.loadKeywords();
      this.calculateOpportunityScores();
      await this.generatePrioritizedReport();
      await this.exportPrioritizedCSV();

      console.log('\n‚úÖ Analysis complete!');
      console.log('\nüìã Files generated:');
      console.log('   üìÑ scripts/reports/opportunity-prioritization-report.md');
      console.log('   üìä scripts/reports/prioritized-keywords.csv');
      
      console.log('\nüéØ Next Steps:');
      console.log('1. Review the prioritization report');
      console.log('2. Start with URGENT and LOW-HANGING keywords');
      console.log('3. Focus on NOT-RANKING high-volume keywords');
      console.log('4. Address DECLINING keywords immediately');

    } catch (error) {
      console.error('‚ùå Analysis failed:', error.message);
      process.exit(1);
    }
  }
}

// Run if called directly
if (require.main === module) {
  const analyzer = new OpportunityAnalyzer();
  analyzer.runAnalysis();
}

module.exports = OpportunityAnalyzer;